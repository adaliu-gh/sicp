(define (make-queue)
  (let ((fron-ptr '())
        (rear-ptr '()))
    ;; predicate
    (define (empty-queue?)
      (null? fron-ptr))
    ;; mutators
    (define (insert-queue! v)
      (let ((new-pair (cons v '())))
        (if (empty-queue?)
            (begin (set! fron-ptr new-pair)
                   (set! rear-ptr new-pair))
            (begin (set-cdr! rear-ptr new-pair)
                   (set! rear-ptr new-pair)))))
    (define (delete-queue!)
      (if (empty-queue?)
          (error "empty")
          (set! fron-ptr (cdr fron-ptr))))
    (define (dispatch m)
      (cond
       ((eq? m 'fron-ptr) fron-ptr)
       ((eq? m 'rear-ptr) rear-ptr)
       ((eq? m 'set-fron-ptr!) set-fron-ptr!)
       ((eq? m 'set-rear-ptr!) set-rear-ptr!)
       ((eq? m 'empty-queue?) (empty-queue?))
       ((eq? m 'insert-queue!) insert-queue!)
       ((eq? m 'delete-queue!) (delete-queue!))))
    dispatch))

(define (empty-queue? q)
  (q 'empty-queue?))
(define (fron-ptr q)
  (q 'fron-ptr))
(define (rear-ptr q)
  (q 'rear-ptr))
(define (front-queue q)
  (if (empty-queue? q)
      (error "empty")
      (car (fron-ptr q))))

(define (insert-queue! q v)
  ((q 'insert-queue!) v) q)
(define (delete-queue! q)
  (q 'delete-queue!) q)
(define (print-queue q)
  (fron-ptr q))


